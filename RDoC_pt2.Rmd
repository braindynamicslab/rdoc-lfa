---
title: "Internal validation using whole-brain activation maps (run RDoC_pt1 first for some required variables)"
author: "Shaun Quah"
date: "2023-10-06"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library("rio")
library(psych) 
library(psychTools)
library(xtable)
library(gplots)
library(ggplot2)
library(lavaan)
library(semPlot)
library(openxlsx)
library(igraph)
library(circlize)
```

```{r, fig.height = 8, fig.width = 8}
data_exc <- import('Dataset Maps.xlsx',sheet='Wholebrain Held-out Maps')

data_exc[] <- lapply(data_exc, as.numeric)
data_exc <- apply(data_exc, 2, scale)
num_items <- fa.parallel(data_exc, fm="pa", fa="fa")

correlation_matrix <- cor(data_exc)
heatmap.2(data.matrix(correlation_matrix), dendrogram = c("none"), Rowv = NA, Colv = NA, trace="none",col="bluered")
```

# Data-driven internal validation model
```{r, fig.height = 8, fig.width = 8}
# Initialize a list to store assignments for each factor
assignments_list <- list()

# Initialize a list to store the highest sum of products for each factor
highest_sums <- list()

# Loop through each variable in data_exc
for (var_name in colnames(data_exc)) {
  # Initialize variables to keep track of the best factor and its sum of products
  best_factor <- NULL
  best_sum_of_products <- -Inf

  # Calculate the sums of products for each factor
  for (i in 1:length(colnames(dd.cbfa.fscores_nog))) {
    factor_name <- colnames(dd.cbfa.fscores_nog)[i]
    product_sum <- sum(data_exc[, var_name] * dd.cbfa.fscores_nog[, factor_name])
    
    # Check if this factor has a higher sum of products
    if (product_sum > best_sum_of_products) {
      best_factor <- factor_name
      best_sum_of_products <- product_sum
    }
  }
  
  # Store the highest sum of products for each factor
  if (!(best_factor %in% names(highest_sums)) || best_sum_of_products > highest_sums[[best_factor]]) {
    highest_sums[[best_factor]] <- best_sum_of_products
  }
  
  # Append the assignment to the corresponding factor's list
  if (!(best_factor %in% names(assignments_list))) {
    assignments_list[[best_factor]] <- character(0)
  }
  assignments_list[[best_factor]] <- c(assignments_list[[best_factor]], var_name)
}

# Combine assignments into the final CFA model specification with adjusted coefficients
cfa.testfit.model <- sapply(names(assignments_list), function(factor_name) {
  factor_assignments <- assignments_list[[factor_name]]
  highest_sum <- highest_sums[[factor_name]]
  
  # Divide each variable's best_sum_of_products by the highest and format the assignment
  adjusted_assignments <- sapply(factor_assignments, function(var_name) {
    sum_of_products <- sum(data_exc[, var_name] * dd.cbfa.fscores_nog[, factor_name])
    coefficient <- round(sum_of_products / highest_sum, 2)
    paste(coefficient, "*", var_name)
  })
  
  paste(factor_name, "=~", paste(adjusted_assignments, collapse = " + "))
})

all_variables <- colnames(data_exc)
g_definition <- paste("g =~", paste(all_variables, collapse = " + "))
cfa.testfit.model <- c(g_definition, cfa.testfit.model)

# Print the final CFA model specification
cat(paste(cfa.testfit.model, collapse = "\n"))
```

# RDoC internal validation model
```{r, fig.height = 8, fig.width = 8}
# Initialize a list to store assignments for each factor
assignments_list <- list()

# Initialize a list to store the highest sum of products for each factor
highest_sums <- list()

# Loop through each variable in data_exc
for (var_name in colnames(data_exc)) {
  # Initialize variables to keep track of the best factor and its sum of products
  best_factor <- NULL
  best_sum_of_products <- -Inf

  # Calculate the sums of products for each factor
  for (i in 1:length(colnames(rdoc.cfa.fscores))) {
    factor_name <- colnames(rdoc.cfa.fscores)[i]
    product_sum <- sum(data_exc[, var_name] * rdoc.cfa.fscores[, factor_name])
    
    # Check if this factor has a higher sum of products
    if (product_sum > best_sum_of_products) {
      best_factor <- factor_name
      best_sum_of_products <- product_sum
    }
  }
  
  # Store the highest sum of products for each factor
  if (!(best_factor %in% names(highest_sums)) || best_sum_of_products > highest_sums[[best_factor]]) {
    highest_sums[[best_factor]] <- best_sum_of_products
  }
  
  # Append the assignment to the corresponding factor's list
  if (!(best_factor %in% names(assignments_list))) {
    assignments_list[[best_factor]] <- character(0)
  }
  assignments_list[[best_factor]] <- c(assignments_list[[best_factor]], var_name)
}

# Combine assignments into the final CFA model specification with adjusted coefficients
rdoc.testfit.model <- sapply(names(assignments_list), function(factor_name) {
  factor_assignments <- assignments_list[[factor_name]]
  highest_sum <- highest_sums[[factor_name]]
  
  # Divide each variable's best_sum_of_products by the highest and format the assignment
  adjusted_assignments <- sapply(factor_assignments, function(var_name) {
    sum_of_products <- sum(data_exc[, var_name] * rdoc.cfa.fscores[, factor_name])
    coefficient <- round(sum_of_products / highest_sum, 2)
    paste(coefficient, "*", var_name)
  })
  
  paste(factor_name, "=~", paste(adjusted_assignments, collapse = " + "))
})

# Print the final CFA model specification
cat(paste(rdoc.testfit.model, collapse = "\n"))
```

```{r, fig.height = 10, fig.width = 10}
cfa.testfit = cfa(cfa.testfit.model, data_exc, estimator = "MLR", std.lv = TRUE, orthogonal = TRUE, check.gradient = FALSE)
semPaths(cfa.testfit, whatLabels = "std", layout="tree", edge.label.cex=1)
summary(cfa.testfit, standardized=TRUE, rsquare=TRUE, fit.measures=TRUE)
cfa.testfit.r2 = inspect(cfa.testfit, 'r2')

cfa.testfit.loadings = inspect(cfa.testfit,what="std")$lambda
cfa.testfit.loadings = cfa.testfit.loadings[order(row.names(cfa.testfit.loadings)), ]
cfa.testfit.loadings = cfa.testfit.loadings[, order(colnames(cfa.testfit.loadings))]
plot = heatmap.2(data.matrix(cfa.testfit.loadings), dendrogram = c("none"), Rowv = NA, Colv = NA, trace="none",col="bluered")

lavInspect(cfa.testfit, "cov.lv")
```

Rerun cfa.testfit with some variable's variance set to 0 as estimated ov variances are negative
```{r, fig.height = 10, fig.width = 10}
cfa.testfit.model <- c(cfa.testfit.model, "CSP44657 ~~ 0*CSP44657", "CSCC9996 ~~ 0*CSCC9996", "SPSC110105 ~~ 0*SPSC110105", "CSCC453 ~~ 0*CSCC453")

cfa.testfit = cfa(cfa.testfit.model, data_exc, estimator = "MLR", std.lv = TRUE, orthogonal = TRUE, check.gradient = FALSE)
semPaths(cfa.testfit, whatLabels = "std", layout="tree", edge.label.cex=1)
summary(cfa.testfit, standardized=TRUE, rsquare=TRUE, fit.measures=TRUE)
cfa.testfit.r2 = inspect(cfa.testfit, 'r2')

cfa.testfit.loadings = inspect(cfa.testfit,what="std")$lambda
cfa.testfit.loadings = cfa.testfit.loadings[order(row.names(cfa.testfit.loadings)), ]
cfa.testfit.loadings = cfa.testfit.loadings[, order(colnames(cfa.testfit.loadings))]
plot = heatmap.2(data.matrix(cfa.testfit.loadings), dendrogram = c("none"), Rowv = NA, Colv = NA, trace="none",col="bluered")

cfa.testfit.rmsea = fitMeasures(cfa.testfit, c("rmsea.robust", "rmsea.ci.lower.robust", "rmsea.ci.upper.robust", "rmsea.pvalue.robust", "rmsea"))
cfa.testfit.cfi = fitMeasures(cfa.testfit, c("cfi.robust", "tli.robust", "srmr.robust"))
cfa.testfit.tli = fitMeasures(cfa.testfit, c("tli.robust"))
cfa.testfit.aicbic = fitMeasures(cfa.testfit, c("aic", "bic"))
lavInspect(cfa.testfit, "cov.lv")
```

```{r, fig.height = 10, fig.width = 10}
rdoc.testfit = cfa(rdoc.testfit.model, data_exc, estimator = "MLR", std.lv = TRUE,check.gradient = FALSE)
semPaths(rdoc.testfit, whatLabels = "std", layout="tree", edge.label.cex=1)
summary(rdoc.testfit, standardized=TRUE, rsquare=TRUE, fit.measures=TRUE)
rdoc.testfit.r2 = inspect(rdoc.testfit, 'r2')

rdoc.testfit.loadings = inspect(rdoc.testfit,what="std")$lambda
rdoc.testfit.loadings = rdoc.testfit.loadings[order(row.names(rdoc.testfit.loadings)), ]
rdoc.testfit.loadings = rdoc.testfit.loadings[, order(colnames(rdoc.testfit.loadings))]
plot = heatmap.2(data.matrix(rdoc.testfit.loadings), dendrogram = c("none"), Rowv = NA, Colv = NA, trace="none",col = colorRampPalette(c("white", "red"))(100))

rdoc.testfit.rmsea = fitMeasures(rdoc.testfit, c("rmsea.robust", "rmsea.ci.lower.robust", "rmsea.ci.upper.robust", "rmsea.pvalue.robust", "rmsea"))
rdoc.testfit.cfi = fitMeasures(rdoc.testfit, c("cfi.robust", "tli.robust", "srmr.robust"))
rdoc.testfit.tli = fitMeasures(rdoc.testfit, c("tli.robust"))
rdoc.testfit.aicbic = fitMeasures(rdoc.testfit, c("aic", "bic"))

lavInspect(rdoc.testfit, "cov.lv")
```

#Bootstrap by resampling parcels
```{r, fig.height = 8, fig.width = 6}
set.seed(5)
rdoc.testfit.bs <- bootstrapLavaan(rdoc.testfit, R = 5000, type = "yuan", FUN = function(x) {
  fitMeasures(x, fit.measures = c("cfi.robust","tli.robust", "aic", "bic","rmsea.robust","srmr")) })

cfa.testfit.bs <- bootstrapLavaan(cfa.testfit, R = 5000, type = "yuan", FUN = function(x) {
  fitMeasures(x, fit.measures = c("cfi.robust","tli.robust", "aic", "bic","rmsea.robust","srmr")) })

save(rdoc.testfit.bs, file = "rdoc.testfit.exc_5kbsyuan.RData")
save(cfa.testfit.bs, file = "cfa.testfit.exc_5kbsyuan.RData")
```

```{r, fig.height = 8, fig.width = 6}
rdoc.testfit.cfi.ci = quantile(rdoc.testfit.bs[, 1], probs = c(.025, .975), na.rm = TRUE)
rdoc.testfit.tli.ci = quantile(rdoc.testfit.bs[, 2], probs = c(.025, .975), na.rm = TRUE)
rdoc.testfit.aic.ci = quantile(rdoc.testfit.bs[, 3], probs = c(.025, .975), na.rm = TRUE)
rdoc.testfit.bic.ci = quantile(rdoc.testfit.bs[, 4], probs = c(.025, .975), na.rm = TRUE)
rdoc.testfit.rmsea.ci = quantile(rdoc.testfit.bs[, 5], probs = c(.025, .975), na.rm = TRUE)

cfa.testfit.cfi.ci = quantile(cfa.testfit.bs[, 1], probs = c(.025, .975), na.rm = TRUE)
cfa.testfit.tli.ci = quantile(cfa.testfit.bs[, 2], probs = c(.025, .975), na.rm = TRUE)
cfa.testfit.aic.ci = quantile(cfa.testfit.bs[, 3], probs = c(.025, .975), na.rm = TRUE)
cfa.testfit.bic.ci = quantile(cfa.testfit.bs[, 4], probs = c(.025, .975), na.rm = TRUE)
cfa.testfit.rmsea.ci = quantile(cfa.testfit.bs[, 5], probs = c(.025, .975), na.rm = TRUE)

hist(rdoc.testfit.bs[, 1])
hist(rdoc.testfit.bs[, 2])
hist(rdoc.testfit.bs[, 3])
hist(rdoc.testfit.bs[, 4])
hist(rdoc.testfit.bs[, 5])
hist(rdoc.testfit.bs[, 6])

hist(cfa.testfit.bs[, 1])
hist(cfa.testfit.bs[, 2])
hist(cfa.testfit.bs[, 3])
hist(cfa.testfit.bs[, 4])
hist(cfa.testfit.bs[, 5])
hist(cfa.testfit.bs[, 6])
```

```{r, fig.height = 4, fig.width = 4}
fitdata <- data.frame(Models = c("RDoC", "DD"), 
                   Robust.RMSEA =  c(rdoc.testfit.rmsea[1], cfa.testfit.rmsea[1]), 
                   errmin2 = c(rdoc.testfit.rmsea.ci[[1]], cfa.testfit.rmsea.ci[[1]]),
                   errmax2 = c(rdoc.testfit.rmsea.ci[[2]], cfa.testfit.rmsea.ci[[2]]),
                   Robust.CFI = c(rdoc.testfit.cfi[1], cfa.testfit.cfi[1]),
                   cfi.errmin = c(rdoc.testfit.cfi.ci[[1]], cfa.testfit.cfi.ci[[1]]), 
                   cfi.errmax = c(rdoc.testfit.cfi.ci[[2]], cfa.testfit.cfi.ci[[2]]), 
                   Robust.TLI = c(rdoc.testfit.cfi[2], cfa.testfit.cfi[2]), 
                   tli.errmin = c(rdoc.testfit.tli.ci[[1]], cfa.testfit.tli.ci[[1]]),
                   tli.errmax = c(rdoc.testfit.tli.ci[[2]], cfa.testfit.tli.ci[[2]]),
                   aic = c(rdoc.testfit.aicbic[1], cfa.testfit.aicbic[1]),
                   aic.errmin = c(rdoc.testfit.aic.ci[[1]], cfa.testfit.aic.ci[[1]]),
                   aic.errmax = c(rdoc.testfit.aic.ci[[2]], cfa.testfit.aic.ci[[2]]),
                   bic = c(rdoc.testfit.aicbic[2], cfa.testfit.aicbic[2]),
                   bic.errmin = c(rdoc.testfit.bic.ci[[1]], cfa.testfit.bic.ci[[1]]),
                   bic.errmax = c(rdoc.testfit.bic.ci[[2]], cfa.testfit.bic.ci[[2]])
                   )

ggplot(fitdata, aes(x = Models, y = Robust.RMSEA)) +
  geom_bar(stat='identity', color="black", fill="skyblue", width=0.5) + 
  geom_errorbar(aes(x = Models, ymin=errmin2, ymax=errmax2), width=0.4, colour="orange", size=1.3) +
  scale_y_continuous(expand = expansion(mult = c(0, .1)))+ 
  ggtitle("Robust RMSEA bootstrap")+
  labs(y = "RMSEA") +
  theme_classic()

ggplot(fitdata, aes(x = Models, y = Robust.CFI)) +
  geom_bar(stat='identity', color="black", fill="skyblue", width=0.5) + 
  geom_errorbar(aes(x = Models, ymin=cfi.errmin, ymax=cfi.errmax), width=0.4, colour="orange", size=1.3) +
  scale_y_continuous(expand = expansion(mult = c(0, .1)))+ 
  ggtitle("Robust CFI")+
  labs(y = "CFI")+
  theme_classic()

ggplot(fitdata, aes(x = Models, y = Robust.TLI)) +
  geom_bar(stat='identity', color="black", fill="skyblue", width=0.5) + 
  geom_errorbar(aes(x = Models, ymin=tli.errmin, ymax=tli.errmax), width=0.4, colour="orange", size=1.3) +
  scale_y_continuous(expand = expansion(mult = c(0, .1)))+ 
  ggtitle("Robust TLI")+
  labs(y = "TLI")+
  theme_classic()

ggplot(fitdata, aes(x = Models, y = aic)) +
  geom_bar(stat='identity', color="black", fill="skyblue", width=0.5) + 
  geom_errorbar(aes(x = Models, ymin=aic.errmin, ymax=aic.errmax), width=0.4, colour="orange", size=1.3) +
  scale_y_continuous(expand = expansion(mult = c(0, .1)))+ 
  ggtitle("AIC")+
  labs(y = "AIC")+
  theme_classic()

ggplot(fitdata, aes(x = Models, y = bic)) +
  geom_bar(stat='identity', color="black", fill="skyblue", width=0.5) + 
  geom_errorbar(aes(x = Models, ymin=bic.errmin, ymax=bic.errmax), width=0.4, colour="orange", size=1.3) +
  scale_y_continuous(expand = expansion(mult = c(0, .1)))+ 
  ggtitle("BIC")+
  labs(y = "BIC")+
  theme_classic()

save(fitdata, file = "fitdata_testfit_exc.RData")
fitdata_exc = fitdata
fitdata_exc[, -1] <- round(fitdata_exc[, -1], 3)
fitdata_exc[, (ncol(fitdata_exc) - 5):ncol(fitdata_exc)] <- round(fitdata_exc[, (ncol(fitdata_exc) - 5):ncol(fitdata_exc)], 0)
print(fitdata_exc)
```

```{r, fig.height = 7.5, fig.width = 7.5}
plot_metric <- function(metric_name, real_metric = NULL, real_metric_name = NULL, title = "") {
  combined_metric <- rbind(
    data.frame(Model = "RDoC", Metric = rdoc.testfit.bs[, metric_name]),
    data.frame(Model = "CFA", Metric = cfa.testfit.bs[, metric_name])
  )
  
  p <- ggplot(combined_metric, aes(x = Model, y = Metric, fill = Model)) +
    geom_violin(trim = FALSE) +
    labs(title = title, y = metric_name, x = "") +
    theme_minimal() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      axis.line = element_line(size = 1.2), # Increase size for thicker lines
      axis.ticks = element_line(size = 1.2), # Increase size for thicker ticks
      axis.ticks.length = unit(0.2, "cm") # Increase tick length
    ) +
    scale_fill_brewer(palette = "Pastel1")
  
  if (!is.null(real_metric)) {
    real_metric_df <- data.frame(
      Model = c("RDoC", "CFA"),
      RealMetric = real_metric
    )
    p <- p + geom_quasirandom(data = real_metric_df, aes(x = Model, y = RealMetric), color = "black", size = 3)
  }
  
  print(p)
}

# Usage for each metric
plot_metric("cfi.robust", c(fitdata_exc$Robust.CFI[1], fitdata_exc$Robust.CFI[2]), "RealCFI", "Distribution of CFI")
plot_metric("tli.robust",c(fitdata_exc$Robust.TLI[1], fitdata_exc$Robust.TLI[2]), "RealTLI", title = "Distribution of TLI")
plot_metric("aic", c(fitdata_exc$aic[1], fitdata_exc$aic[2]), "RealAIC", title = "Distribution of AIC")
plot_metric("bic", c(fitdata_exc$bic[1], fitdata_exc$bic[2]), "RealBIC", title = "Distribution of BIC")
plot_metric("rmsea.robust", c(fitdata_exc$Robust.RMSEA[1], fitdata_exc$Robust.RMSEA[2]), "RealRMSEA", title = "Distribution of RMSEA")
```

```{r, fig.height = 4, fig.width = 4}
column_labels <- c("cfi", "tli", "aic", "bic", "rmsea")

for (i in 1:5) {
  cat("Column:", column_labels[i], "\n")
  
  # Perform the t-test and ignore NaN values
  t_result <- t.test(rdoc.testfit.bs[, i], cfa.testfit.bs[, i], na.action = na.exclude)
  
  # Extract the t-statistic, p-value, and degrees of freedom
  t_statistic <- t_result$statistic
  p_value <- round(t_result$p.value, 3)
  degrees_of_freedom <- t_result$parameter
  
  # Determine the significance
  significance <- ifelse(p_value < 0.05, "Significant", "Not Significant")
  
  # Print the results for the current column
  cat("T-Statistic:", t_statistic, "\n")
  cat("Degrees of Freedom:", degrees_of_freedom, "\n") # This line ensures degrees of freedom are displayed
  cat("P-Value:", p_value, "\n")
  cat("Significance:", significance, "\n\n")
}
```

```{r, fig.height = 4, fig.width = 4}
column_labels <- c("cfi", "tli", "aic", "bic", "rmsea")

for (i in 1:5) {
  cat("Column:", column_labels[i], "\n")

  # Perform the Mann-Whitney U Test and ignore NaN values
  mw_result <- wilcox.test(rdoc.testfit.bs[, i], cfa.testfit.bs[, i], na.action = na.exclude)

  # Extract the W statistic (U statistic in other software), p-value, and add manual calculation for degrees of freedom if needed
  w_statistic <- mw_result$statistic
  p_value <- round(mw_result$p.value, 3)
  # Mann-Whitney U Test does not inherently have degrees of freedom, so this part is omitted

  # Determine the significance
  if (p_value < 0.05) {
    significance <- "Significant"
  } else {
    significance <- "Not Significant"
  }

  # Print the results for the current column
  cat("W-Statistic (U):", w_statistic, "\n")
  cat("P-Value:", p_value, "\n")
  cat("Significance:", significance, "\n\n")
}
```
